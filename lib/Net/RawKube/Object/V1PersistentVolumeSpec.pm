=begin comment

Kubernetes

No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: v1.7.4

Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package Net::RawKube::Object::V1PersistentVolumeSpec;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;

use base ("Class::Accessor", "Class::Data::Inheritable");


#
#PersistentVolumeSpec is the specification of a persistent volume.
#
# NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
# REF: https://github.com/swagger-api/swagger-codegen
#

=begin comment

Kubernetes

No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: v1.7.4

Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
__PACKAGE__->mk_classdata('attribute_map' => {});
__PACKAGE__->mk_classdata('swagger_types' => {});
__PACKAGE__->mk_classdata('method_documentation' => {}); 
__PACKAGE__->mk_classdata('class_documentation' => {});

# new object
sub new { 
    my ($class, %args) = @_; 

	my $self = bless {}, $class;
	
	foreach my $attribute (keys %{$class->attribute_map}) {
		my $args_key = $class->attribute_map->{$attribute};
		$self->$attribute( $args{ $args_key } );
	}
	
	return $self;
}  

# return perl hash
sub to_hash {
    return decode_json(JSON->new->convert_blessed->encode( shift ));
}

# used by JSON for serialization
sub TO_JSON { 
    my $self = shift;
    my $_data = {};
    foreach my $_key (keys %{$self->attribute_map}) {
        if (defined $self->{$_key}) {
            $_data->{$self->attribute_map->{$_key}} = $self->{$_key};
        }
    }
    return $_data;
}

# from Perl hashref
sub from_hash {
    my ($self, $hash) = @_;

    # loop through attributes and use swagger_types to deserialize the data
    while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
    	my $_json_attribute = $self->attribute_map->{$_key}; 
        if ($_type =~ /^array\[/i) { # array
            my $_subclass = substr($_type, 6, -1);
            my @_array = ();
            foreach my $_element (@{$hash->{$_json_attribute}}) {
                push @_array, $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \@_array;
        } elsif (exists $hash->{$_json_attribute}) { #hash(model), primitive, datetime
            $self->{$_key} = $self->_deserialize($_type, $hash->{$_json_attribute});
        } else {
        	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
        }
    }
  
    return $self;
}

# deserialize non-array data
sub _deserialize {
    my ($self, $type, $data) = @_;
    $log->debugf("deserializing %s with %s",Dumper($data), $type);
        
    if ($type eq 'DateTime') {
        return DateTime->from_epoch(epoch => str2time($data));
    } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
        return $data;
    } else { # hash(model)
        my $_instance = eval "Net::RawKube::Object::$type->new()";
        return $_instance->from_hash($data);
    }
}



__PACKAGE__->class_documentation({description => 'PersistentVolumeSpec is the specification of a persistent volume.',
                                  class => 'V1PersistentVolumeSpec',
                                  required => [], # TODO
}                                 );

__PACKAGE__->method_documentation({
    'access_modes' => {
    	datatype => 'ARRAY[string]',
    	base_name => 'accessModes',
    	description => 'AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes',
    	format => '',
    	read_only => '',
    		},
    'aws_elastic_block_store' => {
    	datatype => 'V1AWSElasticBlockStoreVolumeSource',
    	base_name => 'awsElasticBlockStore',
    	description => 'AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore',
    	format => '',
    	read_only => '',
    		},
    'azure_disk' => {
    	datatype => 'V1AzureDiskVolumeSource',
    	base_name => 'azureDisk',
    	description => 'AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.',
    	format => '',
    	read_only => '',
    		},
    'azure_file' => {
    	datatype => 'V1AzureFileVolumeSource',
    	base_name => 'azureFile',
    	description => 'AzureFile represents an Azure File Service mount on the host and bind mount to the pod.',
    	format => '',
    	read_only => '',
    		},
    'capacity' => {
    	datatype => 'HASH[string,string]',
    	base_name => 'capacity',
    	description => 'A description of the persistent volume&#39;s resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity',
    	format => '',
    	read_only => '',
    		},
    'cephfs' => {
    	datatype => 'V1CephFSVolumeSource',
    	base_name => 'cephfs',
    	description => 'CephFS represents a Ceph FS mount on the host that shares a pod&#39;s lifetime',
    	format => '',
    	read_only => '',
    		},
    'cinder' => {
    	datatype => 'V1CinderVolumeSource',
    	base_name => 'cinder',
    	description => 'Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md',
    	format => '',
    	read_only => '',
    		},
    'claim_ref' => {
    	datatype => 'V1ObjectReference',
    	base_name => 'claimRef',
    	description => 'ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding',
    	format => '',
    	read_only => '',
    		},
    'fc' => {
    	datatype => 'V1FCVolumeSource',
    	base_name => 'fc',
    	description => 'FC represents a Fibre Channel resource that is attached to a kubelet&#39;s host machine and then exposed to the pod.',
    	format => '',
    	read_only => '',
    		},
    'flex_volume' => {
    	datatype => 'V1FlexVolumeSource',
    	base_name => 'flexVolume',
    	description => 'FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.',
    	format => '',
    	read_only => '',
    		},
    'flocker' => {
    	datatype => 'V1FlockerVolumeSource',
    	base_name => 'flocker',
    	description => 'Flocker represents a Flocker volume attached to a kubelet&#39;s host machine and exposed to the pod for its usage. This depends on the Flocker control service being running',
    	format => '',
    	read_only => '',
    		},
    'gce_persistent_disk' => {
    	datatype => 'V1GCEPersistentDiskVolumeSource',
    	base_name => 'gcePersistentDisk',
    	description => 'GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk',
    	format => '',
    	read_only => '',
    		},
    'glusterfs' => {
    	datatype => 'V1GlusterfsVolumeSource',
    	base_name => 'glusterfs',
    	description => 'Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md',
    	format => '',
    	read_only => '',
    		},
    'host_path' => {
    	datatype => 'V1HostPathVolumeSource',
    	base_name => 'hostPath',
    	description => 'HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath',
    	format => '',
    	read_only => '',
    		},
    'iscsi' => {
    	datatype => 'V1ISCSIVolumeSource',
    	base_name => 'iscsi',
    	description => 'ISCSI represents an ISCSI Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. Provisioned by an admin.',
    	format => '',
    	read_only => '',
    		},
    'local' => {
    	datatype => 'V1LocalVolumeSource',
    	base_name => 'local',
    	description => 'Local represents directly-attached storage with node affinity',
    	format => '',
    	read_only => '',
    		},
    'nfs' => {
    	datatype => 'V1NFSVolumeSource',
    	base_name => 'nfs',
    	description => 'NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs',
    	format => '',
    	read_only => '',
    		},
    'persistent_volume_reclaim_policy' => {
    	datatype => 'string',
    	base_name => 'persistentVolumeReclaimPolicy',
    	description => 'What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming',
    	format => '',
    	read_only => '',
    		},
    'photon_persistent_disk' => {
    	datatype => 'V1PhotonPersistentDiskVolumeSource',
    	base_name => 'photonPersistentDisk',
    	description => 'PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine',
    	format => '',
    	read_only => '',
    		},
    'portworx_volume' => {
    	datatype => 'V1PortworxVolumeSource',
    	base_name => 'portworxVolume',
    	description => 'PortworxVolume represents a portworx volume attached and mounted on kubelets host machine',
    	format => '',
    	read_only => '',
    		},
    'quobyte' => {
    	datatype => 'V1QuobyteVolumeSource',
    	base_name => 'quobyte',
    	description => 'Quobyte represents a Quobyte mount on the host that shares a pod&#39;s lifetime',
    	format => '',
    	read_only => '',
    		},
    'rbd' => {
    	datatype => 'V1RBDVolumeSource',
    	base_name => 'rbd',
    	description => 'RBD represents a Rados Block Device mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md',
    	format => '',
    	read_only => '',
    		},
    'scale_io' => {
    	datatype => 'V1ScaleIOVolumeSource',
    	base_name => 'scaleIO',
    	description => 'ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.',
    	format => '',
    	read_only => '',
    		},
    'storage_class_name' => {
    	datatype => 'string',
    	base_name => 'storageClassName',
    	description => 'Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.',
    	format => '',
    	read_only => '',
    		},
    'storageos' => {
    	datatype => 'V1StorageOSPersistentVolumeSource',
    	base_name => 'storageos',
    	description => 'StorageOS represents a StorageOS volume that is attached to the kubelet&#39;s host machine and mounted into the pod More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md',
    	format => '',
    	read_only => '',
    		},
    'vsphere_volume' => {
    	datatype => 'V1VsphereVirtualDiskVolumeSource',
    	base_name => 'vsphereVolume',
    	description => 'VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine',
    	format => '',
    	read_only => '',
    		},
});

__PACKAGE__->swagger_types( {
    'access_modes' => 'ARRAY[string]',
    'aws_elastic_block_store' => 'V1AWSElasticBlockStoreVolumeSource',
    'azure_disk' => 'V1AzureDiskVolumeSource',
    'azure_file' => 'V1AzureFileVolumeSource',
    'capacity' => 'HASH[string,string]',
    'cephfs' => 'V1CephFSVolumeSource',
    'cinder' => 'V1CinderVolumeSource',
    'claim_ref' => 'V1ObjectReference',
    'fc' => 'V1FCVolumeSource',
    'flex_volume' => 'V1FlexVolumeSource',
    'flocker' => 'V1FlockerVolumeSource',
    'gce_persistent_disk' => 'V1GCEPersistentDiskVolumeSource',
    'glusterfs' => 'V1GlusterfsVolumeSource',
    'host_path' => 'V1HostPathVolumeSource',
    'iscsi' => 'V1ISCSIVolumeSource',
    'local' => 'V1LocalVolumeSource',
    'nfs' => 'V1NFSVolumeSource',
    'persistent_volume_reclaim_policy' => 'string',
    'photon_persistent_disk' => 'V1PhotonPersistentDiskVolumeSource',
    'portworx_volume' => 'V1PortworxVolumeSource',
    'quobyte' => 'V1QuobyteVolumeSource',
    'rbd' => 'V1RBDVolumeSource',
    'scale_io' => 'V1ScaleIOVolumeSource',
    'storage_class_name' => 'string',
    'storageos' => 'V1StorageOSPersistentVolumeSource',
    'vsphere_volume' => 'V1VsphereVirtualDiskVolumeSource'
} );

__PACKAGE__->attribute_map( {
    'access_modes' => 'accessModes',
    'aws_elastic_block_store' => 'awsElasticBlockStore',
    'azure_disk' => 'azureDisk',
    'azure_file' => 'azureFile',
    'capacity' => 'capacity',
    'cephfs' => 'cephfs',
    'cinder' => 'cinder',
    'claim_ref' => 'claimRef',
    'fc' => 'fc',
    'flex_volume' => 'flexVolume',
    'flocker' => 'flocker',
    'gce_persistent_disk' => 'gcePersistentDisk',
    'glusterfs' => 'glusterfs',
    'host_path' => 'hostPath',
    'iscsi' => 'iscsi',
    'local' => 'local',
    'nfs' => 'nfs',
    'persistent_volume_reclaim_policy' => 'persistentVolumeReclaimPolicy',
    'photon_persistent_disk' => 'photonPersistentDisk',
    'portworx_volume' => 'portworxVolume',
    'quobyte' => 'quobyte',
    'rbd' => 'rbd',
    'scale_io' => 'scaleIO',
    'storage_class_name' => 'storageClassName',
    'storageos' => 'storageos',
    'vsphere_volume' => 'vsphereVolume'
} );

__PACKAGE__->mk_accessors(keys %{__PACKAGE__->attribute_map});


1;
